# 复杂页面的重构，组件拆分与设计

页面示例 ![页面示例](%E9%A1%B5%E9%9D%A2%E7%A4%BA%E4%BE%8B.png)

## 组件拆分

例子：
1. 标题 & 面包屑
2. 2组工具按钮 （与选中行数据相关 & 不相关）
3. 表格
4. 行内悬浮按钮
5. 分页
6. 一些模态弹窗

- 入口
  - header
    - 标题的多个按钮和弹窗
    - catalog header
  - 表格
  - 目录树

## 数据存储

### 原则
1. 最小公共组件原则
2. 最小权限原则
3. 代码职责


首先找到所有组件需要的state，分析他们的使用情况，是prop，state还是redux数据

按场景区分
1. 进入页面的参数：props
1. 长期有效的缓存：localStorage
2. 当前用户有效，切换页面时保留，如用户相关的查询参数：redux
3. 切换页面不保留，但组件深度，需要深度传递参数，

- props
  - 不会改变的参数：直接使用
  - 会改变的参数：初始化为state
- state：只会在本组件内使用，或传递给下级组件
- redux：1.其他页面共享，2.组件层级太深，传递麻烦

例子：
1. 面包屑数据，关键的projectId等查询参数：props
2. 用户添加的查询参数，如keyword，pagenum：
1. 获取list的参数：其他pageSize需要缓存，保存在redux中
1. list<T>：表格数据列表
2. list<T>: 行首多选框，选中的行的列表
3. T： 悬浮按钮操作所在的行
4. visibles：一些模态弹窗的

### Q: 为什么使用全局数据保存当前页面内的state？

因为该页面复杂，需要仔细拆分组件，数量多层级深，那参数就需要一层层传到最底层的组件。
特别是更新列表数据的回调，可能最底层的一个小组件需要更新，那么回调方法就需要一级级传下去。



### Q：进入页面时，如何重置model和useModel中的数据？

1. 通过传入的props重置全局数据，合适吗？

2. 在页面销毁时重置

## 异步请求
1. 请求：避免重复请求，取消
2. 数据如何

解答
1. 高频请求使用useRequest包装

## 需求

## 二：面包屑
umi框架下，首先，页面跳转时我们通过location取参
```ts
const location = useLocation<StateProps>();
const params = location.state;
```
定义我们自己的state参数的类型StateProps
```ts
type StateProps = {
  param1: number;
  param2: string;
  ...
  breadRoutes: {
    name: string; // 标题
    route: string; // 路由路径
    state: any; // 当前面包屑对应路由的参数
  }[]
}
```

存在的问题
1. 冗余：路由跳转传递breadRoutes，需要手动构建，层级深，
2. 耦合：一个页面参数的修改，需要修改所有对应路由跳转
3. 构建复杂：每个breadRoute需要传的state不一样，需要参考多个页面的props，出错风险高
4. breadRoutes列表最后一个item的state，和StateProps中的其他参数是一致的，存着重复参数

### 方案1：通过路由历史，自动构建面包屑
路由自动构建的问题，与边栏路由历史整合在一起

好处
1. 不需要手动构建breadRoutes[]，避免一些传参的不必要的错误，
2. 省去一些冗余代码，页面传参更清晰

问题：
1. 跨级跳转时不可用：例如从传输列表直接跳到底稿空间，还是需要手动构建。而这种场景很常见


### 方案2：通过路由的层级结构，自动生成面包屑
创建PageLayout，在里面统一处理

好处：
1. 页面参数修改时，只需要改一处
2. 有前提：需要下级页面的参数能覆盖不了上级页面的参数
问题：
1. 需要手动配置

### 方案3：将构建的方法放到每个页面组件内：
不好，耦合问题依然存在

