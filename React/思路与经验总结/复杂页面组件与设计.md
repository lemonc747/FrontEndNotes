# 复杂页面的重构，组件拆分与设计

页面示例 ![页面示例](%E9%A1%B5%E9%9D%A2%E7%A4%BA%E4%BE%8B.png)

## 组件拆分

例子：
1. 标题 & 面包屑
2. 2组工具按钮 （与选中行数据相关 & 不相关）
3. 表格
4. 行内悬浮按钮
5. 分页
6. 一些模态弹窗

## 数据存储

首先找到所有组件需要的state，分析他们的使用情况，是prop，state还是redux数据

按场景区分
1. 进入页面的参数：props
1. 长期有效的缓存：localStorage
2. 当前用户有效，切换页面时保留，如用户相关的查询参数：redux
3. 切换页面不保留，但组件深度，需要深度传递参数，

例子：
1. 面包屑数据，关键的projectId等查询参数：props
2. 用户添加的查询参数，如keyword，pagenum：
1. 获取list的参数：其他pageSize需要缓存，保存在redux中
1. list<T>：表格数据列表
2. list<T>: 行首多选框，选中的行的列表
3. T： 悬浮按钮操作所在的行
4. visibles：一些模态弹窗的

### Q：切换用户时，如何重置model和useModel中的数据？


## 异步请求
1. 请求：避免重复请求，取消
2. 数据如何

解答
1. 高频请求使用useRequest包装

## 需求

## 面包屑：todo，暂缓
umi框架下，首先，页面跳转时我们通过location取参
```ts
const location = useLocation<StateProps>();
const params = location.state;
```
定义我们自己的state参数的类型StateProps
```ts
type StateProps = {
  param1: number;
  param2: string;
  ...
  breadRoutes: {
    name: string; // 标题
    route: string; // 路由路径
    state: any; // 当前面包屑对应路由的参数
  }[]
}
```

存在的问题
1. 冗余：路由跳转传递breadRoutes，需要手动构建，层级深，
2. 耦合：一个页面参数的修改，需要修改所有对应路由跳转
3. 构建复杂：每个breadRoute需要传的state不一样，需要参考多个页面的props，出错风险高
4. breadRoutes列表最后一个item的state，和StateProps中的其他参数是一致的，存着重复参数

### 方案1：通过路由历史，自动构建面包屑
路由自动构建的问题，与边栏路由历史整合在一起

好处
1. 不需要手动构建breadRoutes[]，避免一些传参的不必要的错误，
2. 省去一些冗余代码，页面传参更清晰

问题：
1. 跨级跳转时不可用：例如从传输列表直接跳到底稿空间，还是需要手动构建。而这种场景很常见


### 方案2：在高阶组件内统一处理
创建PageLayout，在里面统一处理

好处：
1. 页面参数修改时，只需要改一处

问题：
1. 需要手动配置

### 方案3：将构建的方法放到每个页面组件内：
不好，
1. 耦合问题依然存在
2. 下级页面的参数如果覆盖不了上级页面的参数，会比较麻烦
